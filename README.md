# cs-300-portfolio-entry
This repository shows run-time analysis of various data structures. It also include C++ to sort and print out a list of CS courses.

<b><i>What was the problem you were trying to solve in the projects for this course?</i></b>

One of the big problems I was trying to solve in this course was to gain an understanding of when to use certain algorithms and data structures for a given situation. There are many ways to approach solving a problem, but some ways are more efficient than others, so learning the skills and knowledge necessary to make informed and logical decisions has been a useful and even fun experience.

<b><i>How did you approach the problem? Consider why data structures are important to understand.</i></b>

I approached the problem in such a way that I was trying to find a good balance between runtime complexity, ease of implementation, and scalability. I decided that ease of implementation was to be given the least priority, and that efficiency and scalability were more important factors. There is often not a perfect solution to a problem, but the trick is finding the solution where the pros outweight the cons. So when solving a problem, I approach it with this in mind.

<b><i>How did you overcome any roadblocks you encountered while going through the activities or project?</i></b>

The biggest roadblocks I faced on these projects boiled down to gaps in my knowledge and understanding, which lead to not knowing the best path forward. I found myself revisiting course materials, watching YouTube videos on relevant topics, and a lot of trial and error. This payed off because I'm much more confident in my analyses and implementations than I was earlier in the course.

<b><i>How has your work on this project expanded your approach to designing software and developing programs?</i></b>

Working on this project has expanded my approach to designing software in that I no longer am just looking for a solution that works, but rather one that works <i>well and efficiently</i>. I have learned the importance of optimization and efficiency when approaching software design. It's easy to say "well, it works, guess my work is done here" when a program executes accurately and without bugs. But if running the program is using huge amount of system resources, that should be addressed.

<b><i>How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?</i></b>

Working on this project has taught me the importance of planning and preparation. When I began programming as a hobby some years ago, I was bad about getting an idea and immediately opening up my IDE and just start typing. I had no plan in mind whatsoever. This lead to a lot of started projects, but very few finished ones. Pursuing this major, this course, and this project has taught me that there is a lot of work to be done before writing a single line of code if you want maintainable, scalable, and efficient code. Gathering requirements, making charts and diagrams, working out my ideas with pseudocode and flow charts are just some of the techniques I have picked up along the way. I've learned that I need to <i>understand</i> what I'm trying to create. And once coding begins, I document it thoroughly for my future self as well as others who may view my code. This shift in perspective has helped me grow as a programmer.
